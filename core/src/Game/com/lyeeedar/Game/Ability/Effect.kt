package com.lyeeedar.Game.Ability

import com.badlogic.gdx.utils.Array
import com.badlogic.gdx.utils.ObjectFloatMap
import com.exp4j.Helpers.evaluate
import com.lyeeedar.Board.*
import com.lyeeedar.Components.*
import com.lyeeedar.Game.Buff
import com.lyeeedar.Game.BuffData
import com.lyeeedar.Game.Global
import com.lyeeedar.Screens.GridScreen
import com.lyeeedar.Statistic
import com.lyeeedar.Util.XmlData
import com.lyeeedar.Util.XmlDataClass
import java.util.*

enum class EffectType
{
	POP,
	CONVERT,
	SUMMON,
	SPREADER,
	SUPERCHARGE,
	BUFF
}

class Effect : XmlDataClass()
{
	lateinit var type: EffectType
	
	var damage: String = "0"
	var convertToRandom: Boolean = false
	var friendly: FriendlyDesc? = null
	var degenSummon: Boolean = true
	var spreader: SpreaderData? = null
	var buff: BuffData? = null

	override fun load(xmlData: XmlData)
	{
	/* Autogenerated method contents. Do not modify. */
		type = EffectType.valueOf(xmlData.get("Type").toUpperCase(Locale.ENGLISH))
		damage = xmlData.get("Damage", "0")!!
		convertToRandom = xmlData.getBoolean("ConvertToRandom", false)
		val friendlyEl = xmlData.getChildByName("Friendly")
		if (friendlyEl != null)
		{
			friendly = FriendlyDesc()
			friendly!!.load(friendlyEl)
		}
		degenSummon = xmlData.getBoolean("DegenSummon", true)
		val spreaderEl = xmlData.getChildByName("Spreader")
		if (spreaderEl != null)
		{
			spreader = SpreaderData()
			spreader!!.load(spreaderEl)
		}
		val buffEl = xmlData.getChildByName("Buff")
		if (buffEl != null)
		{
			buff = BuffData()
			buff!!.load(buffEl)
		}
	}
}

fun Effect.apply(tile: Tile, grid: Grid, delay: Float, originalTargets: Array<Tile>, variables: ObjectFloatMap<String>)
{
	when(type)
	{
		EffectType.POP ->
		{
			val dam = damage.evaluate(variables, grid.ran.nextLong())

			val bonusDam: Float
			if (damage.length == 1)
			{
				// only add on ability dam if we havent used an equation
				bonusDam = dam + grid.level.player.getStat(Statistic.ABILITYDAMAGE)
			}
			else
			{
				bonusDam = dam
			}

			grid.pop(tile, delay, damSource = this, bonusDam = bonusDam, pierce = grid.level.player.getStat(Statistic.PIERCE), skipPowerOrb = true)
		}

		EffectType.CONVERT ->
		{
			val contents = tile.contents
			val matchable = contents?.matchable() ?: return

			val newDesc: OrbDesc
			if (convertToRandom)
			{
				newDesc = OrbDesc.getRandomOrb(grid.level)
			}
			else
			{
				newDesc = originalTargets[0].contents!!.matchable()!!.desc
			}

			matchable.setDesc(newDesc, contents)
		}

		EffectType.SUMMON ->
		{
			val friendly = friendly!!.getEntity(degenSummon, grid)
			friendly.pos()!!.setTile(friendly, tile)
		}

		EffectType.SPREADER ->
		{
			val spreader = Spreader(spreader!!)
			//spreader.damage += Global.player.getStat(Statistic.ABILITYDAMAGE) / 3f
			tile.spreader = spreader
		}

		EffectType.SUPERCHARGE ->
		{
			val contents = tile.contents
			val special = contents?.special() ?: return

			val specialEntity = EntityPool.obtain()
			specialEntity.addComponent(ComponentType.Special)
			val specialHolder = specialEntity.special()!!
			specialHolder.set(DualMatch())

			val merged = special.special.merge(specialEntity) ?: specialHolder.special.merge(contents) ?: special.special
			addSpecial(contents, merged)

			merged.setArmed(true, contents)

			contents.markForDeletion(0f, "merged")

			specialEntity.free()
		}

		EffectType.BUFF ->
		{
			val buff = Buff(buff!!)
			buff.remainingDuration += (Global.player.getStat(Statistic.BUFFDURATION, true) * buff.remainingDuration).toInt()

			val existing = Global.player.levelbuffs.firstOrNull { it.data.nameID == buff.data.nameID }
			if (existing != null)
			{
				existing.remainingDuration += buff.remainingDuration
			}
			else
			{
				Global.player.levelbuffs.add(buff)
			}

			if (!Global.resolveInstantly)
			{
				GridScreen.instance.updateBuffTable()
			}
		}
	}
}