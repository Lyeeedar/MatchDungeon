package com.lyeeedar.Board.CompletionCondition

import com.badlogic.gdx.graphics.Color
import com.badlogic.gdx.scenes.scene2d.ui.Label
import com.badlogic.gdx.scenes.scene2d.ui.Table
import com.badlogic.gdx.utils.Array
import com.badlogic.gdx.utils.ObjectMap
import com.lyeeedar.Board.Grid
import com.lyeeedar.Board.OrbDesc
import com.lyeeedar.Components.Entity
import com.lyeeedar.Components.matchable
import com.lyeeedar.Game.Global
import com.lyeeedar.UI.SpriteWidget
import com.lyeeedar.UI.Tutorial
import com.lyeeedar.Util.*
import ktx.collections.set

class CompletionConditionMatchesData : AbstractCompletionConditionData()
{
	override val classID: String = "Matches"
	
	val toBeMatched: Array<Int> = Array()

	override fun load(xmlData: XmlData)
	{
	/* Autogenerated method contents. Do not modify. */
		super.load(xmlData)
		val toBeMatchedEl = xmlData.getChildByName("ToBeMatched")!!
		for (el in toBeMatchedEl.children)
		{
			toBeMatched.add(el.int())
		}
	}
}

class CompletionConditionMatches(data: CompletionConditionMatchesData): AbstractCompletionCondition<CompletionConditionMatchesData>(data)
{
	val tick = AssetManager.loadSprite("Oryx/uf_split/uf_interface/uf_interface_680", colour = Colour(Color.FOREST))

	val toBeMatched = ObjectMap<OrbDesc, Int>()
	val table = Table()

	override fun createTable(grid: Grid): Table
	{
		rebuildWidget()

		return table
	}

	fun rebuildWidget()
	{
		table.clear()

		var row = Table()
		var counter = 0

		for (entry in toBeMatched.entries())
		{
			val sprite = entry.key.sprite.copy()
			val count = entry.value

			row.add(SpriteWidget(sprite, 24f, 24f)).padLeft(5f)

			if (count == 0)
			{
				row.add(SpriteWidget(tick, 24f, 24f))
			}
			else
			{
				row.add(Label(" x $count", Statics.skin))
			}

			counter++
			if (counter == 2)
			{
				counter = 0
				table.add(row).expand().fill()
				table.row()
				row = Table()
			}
		}

		table.add(row)
	}

	override fun attachHandlers(grid: Grid)
	{
		val valid = Array<OrbDesc>(OrbDesc.getValidOrbs(grid.level))

		toBeMatched.clear()
		for (match in data.toBeMatched)
		{
			if (valid.size > 0)
			{
				toBeMatched[valid.removeRandom(grid.ran)] = match
			}
		}

		grid.onPop += fun(orb: Entity, delay: Float) : HandlerAction {
			val matchable = orb.matchable()!!
			if (toBeMatched.containsKey(matchable.desc))
			{
				var count = toBeMatched[matchable.desc]
				if (count > 0) count--
				toBeMatched[matchable.desc] = count

				rebuildWidget()
			}

			return HandlerAction.KeepAttached
		}

		if (!Global.resolveInstantly)
		{
			Future.call(
				{
					val tutorial = Tutorial("MatchComplete")
					tutorial.addPopup(Localisation.getText("completioncondition.match.tutorial", "UI"), table)
					tutorial.show()
				}, 0.5f)
		}
	}

	override fun isCompleted(): Boolean
	{
		var done = true
		for (entry in toBeMatched.entries())
		{
			if (entry.value > 0)
			{
				done = false
				break
			}
		}

		return done
	}

	override fun getDescription(grid: Grid): Table
	{
		val table = Table()

		table.add(Label(Localisation.getText("completioncondition.match.description", "UI"), Statics.skin))

		for (entry in toBeMatched.entries())
		{
			val sprite = entry.key.sprite
			val count = entry.value

			table.add(SpriteWidget(sprite, 24f, 24f)).padLeft(5f)
			table.add(Label(" x $count", Statics.skin))
		}

		return table
	}
}