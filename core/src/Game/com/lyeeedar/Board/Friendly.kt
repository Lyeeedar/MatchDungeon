package com.lyeeedar.Board

import com.badlogic.gdx.math.Interpolation
import com.badlogic.gdx.math.Vector2
import com.badlogic.gdx.utils.Array
import com.lyeeedar.Board.CompletionCondition.CompletionConditionDie
import com.lyeeedar.Components.*
import com.lyeeedar.Direction
import com.lyeeedar.Renderables.Animation.BumpAnimation
import com.lyeeedar.Renderables.Animation.ExpandAnimation
import com.lyeeedar.Renderables.Animation.LeapAnimation
import com.lyeeedar.Renderables.Animation.MoveAnimation
import com.lyeeedar.Renderables.Particle.ParticleEffect
import com.lyeeedar.Renderables.Sprite.Sprite
import com.lyeeedar.UI.GridWidget
import com.lyeeedar.UI.Tutorial
import com.lyeeedar.Util.*
import ktx.collections.filter
import ktx.collections.toGdxArray
import ktx.math.minus

fun Entity.isFriendly(): Boolean
{
	if (this.hasComponent(ComponentType.Healable) && this.ai()?.ai is FriendlyAI)
	{
		return true
	}

	return false
}

val friendlyBuilder = EntityArchetypeBuilder()
	.add(ComponentType.EntityArchetype)
	.add(ComponentType.Position)
	.add(ComponentType.Renderable)
	.add(ComponentType.AI)
	.add(ComponentType.Healable)
	.add(ComponentType.Tutorial)

fun FriendlyDesc.getEntity(isSummon: Boolean, grid: Grid): Entity
{
	val entity = friendlyBuilder.build()

	entity.archetype()!!.set(EntityArchetype.FRIENDLY)

	val position = entity.pos()!!
	position.size = size

	entity.renderable()!!.set(sprite.copy())

	val healable = entity.healable()!!
	healable.deathEffect = death.copy()
	healable.maxhp = hp
	healable.isSummon = isSummon

	val ai = entity.ai()!!
	ai.ai = FriendlyAI.load(this, grid)

	val tutorialComponent = entity.tutorial()!!
	tutorialComponent.displayTutorial = fun (grid, entity, gridWidget): Tutorial? {
		if (!Statics.settings.get("Friendly", false) )
		{
			val tutorial = Tutorial("Friendly")
			tutorial.addPopup(Localisation.getText("friendly.tutorial", "UI"), gridWidget.getRect(entity))
			return tutorial
		}

		return null
	}

	return entity
}

@DataClass(name = "Friendly", global = true)
class FriendlyDesc : XmlDataClass()
{
	lateinit var sprite: Sprite
	lateinit var death: ParticleEffect

	@NumericRange(min = 1f)
	var size: Int = 1

	@NumericRange(min = 1f)
	var hp: Int = 10

	val abilities: Array<AbstractFriendlyAbilityData> = Array()

	override fun load(xmlData: XmlData)
	{
	/* Autogenerated method contents. Do not modify. */
		sprite = AssetManager.loadSprite(xmlData.getChildByName("Sprite")!!)
		death = AssetManager.loadParticleEffect(xmlData.getChildByName("Death")!!).getParticleEffect()
		size = xmlData.getInt("Size", 1)
		hp = xmlData.getInt("Hp", 10)
		val abilitiesEl = xmlData.getChildByName("Abilities")!!
		for (el in abilitiesEl.children)
		{
			val obj = AbstractFriendlyAbilityData.loadPolymorphicClass(el.get("classID"))
			obj.load(el)
			abilities.add(obj)
		}
	}
}

class FriendlyAI(val abilities: Array<FriendlyAbility<*>>) : AbstractGridAI()
{
	override fun onTurn(entity: Entity, grid: Grid)
	{
		for (ability in abilities.toGdxArray())
		{
			ability.cooldownTimer--
			if (ability.cooldownTimer <= 0)
			{
				ability.cooldownTimer = ability.data.cooldown.x + grid.ran.nextInt(ability.data.cooldown.y - ability.data.cooldown.x)
				ability.activate(entity, grid)
			}
		}
	}

	fun copy(grid: Grid): FriendlyAI
	{
		return FriendlyAI(abilities.map { it.copy(grid) }.toGdxArray())
	}

	companion object
	{
		fun load(desc: FriendlyDesc, grid: Grid): FriendlyAI
		{
			val abilities = Array<FriendlyAbility<*>>()

			for (data in desc.abilities)
			{
				val ability = FriendlyAbility.load(data)
				ability.cooldownTimer = ability.data.cooldown.x + grid.ran.nextInt(ability.data.cooldown.y - ability.data.cooldown.x)
				abilities.add(ability)
			}

			return FriendlyAI(abilities)
		}
	}
}

abstract class AbstractFriendlyAbilityData : XmlDataClass()
{
	@Vector(name1 = "Min", name2 = "Max")
	var cooldown: Point = Point(1, 1)

	var range: Int = 1

	abstract val classID: String

	override fun load(xmlData: XmlData)
	{
	/* Autogenerated method contents. Do not modify. */
		val cooldownRaw = xmlData.get("Cooldown", "1, 1")!!.split(',')
		cooldown = Point(cooldownRaw[0].toInt(), cooldownRaw[1].toInt())
		range = xmlData.getInt("Range", 1)
	}

	companion object
	{
		fun loadPolymorphicClass(classID: String): AbstractFriendlyAbilityData
		{
		/* Autogenerated method contents. Do not modify. */
			return when (classID)
			{
				"Heal" -> FriendlyHealAbilityData()
				"Block" -> FriendlyBlockAbilityData()
				"Pop" -> FriendlyPopAbilityData()
				"Move" -> FriendlyMoveAbilityData()
				"Attack" -> FriendlyAttackAbilityData()
				else -> throw RuntimeException("Unknown classID '$classID' for AbstractFriendlyAbilityData!")
			}
		}
	}
}

abstract class FriendlyAbility<T: AbstractFriendlyAbilityData>(val data: T)
{
	var cooldownTimer: Int = 0

	abstract fun activate(entity: Entity, grid: Grid)
	abstract fun copy(grid: Grid): FriendlyAbility<T>

	companion object
	{
		fun load(data: AbstractFriendlyAbilityData): FriendlyAbility<*>
		{
			val ability = when(data.classID)
			{
				"Attack" -> FriendlyAttackAbility(data as FriendlyAttackAbilityData)
				"Block" -> FriendlyBlockAbility(data as FriendlyBlockAbilityData)
				"Pop" -> FriendlyPopAbility(data as FriendlyPopAbilityData)
				"Heal" -> FriendlyHealAbility(data as FriendlyHealAbilityData)
				"Move" -> FriendlyMoveAbility(data as FriendlyMoveAbilityData)
				else -> throw NotImplementedError()
			}
			return ability
		}
	}
}

abstract class FriendlyPopTileAbilityData : AbstractFriendlyAbilityData()
{
	@NumericRange(min = 1f)
	var damage: Float = 1f
	var flightEffect: ParticleEffect? = null
	var hitEffect: ParticleEffect? = null

	override fun load(xmlData: XmlData)
	{
	/* Autogenerated method contents. Do not modify. */
		super.load(xmlData)
		damage = xmlData.getFloat("Damage", 1f)
		flightEffect = AssetManager.tryLoadParticleEffect(xmlData.getChildByName("FlightEffect"))?.getParticleEffect()
		hitEffect = AssetManager.tryLoadParticleEffect(xmlData.getChildByName("HitEffect"))?.getParticleEffect()
	}

	companion object
	{
		fun loadPolymorphicClass(classID: String): FriendlyPopTileAbilityData
		{
		/* Autogenerated method contents. Do not modify. */
			return when (classID)
			{
				"Block" -> FriendlyBlockAbilityData()
				"Pop" -> FriendlyPopAbilityData()
				"Attack" -> FriendlyAttackAbilityData()
				else -> throw RuntimeException("Unknown classID '$classID' for FriendlyPopTileAbilityData!")
			}
		}
	}
}

abstract class FriendlyPopTileAbility<T: FriendlyPopTileAbilityData>(data: T) : FriendlyAbility<T>(data)
{
	abstract fun getTargets(entity: Entity, grid: Grid): Array<Tile>

	override fun activate(entity: Entity, grid: Grid)
	{
		val pos = entity.pos() ?: return

		val validTargets = getTargets(entity, grid).filter { pos.position.taxiDist(it) <= data.range }

		val tile = validTargets.randomOrNull(grid.ran) ?: return
		val srcTile = pos.tile!!

		var delay = 0f

		val diff = tile.getPosDiff(srcTile)
		diff[0].y *= -1
		entity.renderable()?.renderable?.animation = BumpAnimation.obtain().set(0.2f, diff)

		if (data.flightEffect != null)
		{
			val dst = tile.euclideanDist(srcTile)
			val animDuration = dst * 0.025f

			val particle = data.flightEffect!!.copy()
			particle.animation = MoveAnimation.obtain().set(animDuration, diff)
			particle.killOnAnimComplete = true

			particle.rotation = getRotation(srcTile, tile)

			tile.effects.add(particle)

			delay += animDuration
		}

		if (data.hitEffect != null)
		{
			val particle = data.hitEffect!!.copy()
			particle.renderDelay = delay

			delay += particle.lifetime / 2f

			tile.effects.add(particle)
		}

		grid.pop(tile, delay, bonusDam = data.damage, damSource = entity)
	}
}

class FriendlyAttackAbilityData : FriendlyPopTileAbilityData()
{
	override val classID: String = "Attack"

	override fun load(xmlData: XmlData)
	{
	/* Autogenerated method contents. Do not modify. */
		super.load(xmlData)
	}
}

class FriendlyAttackAbility(data: FriendlyAttackAbilityData) : FriendlyPopTileAbility<FriendlyAttackAbilityData>(data)
{
	override fun getTargets(entity: Entity, grid: Grid): Array<Tile>
	{
		return grid.monsterTiles
	}

	override fun copy(grid: Grid): FriendlyAbility<FriendlyAttackAbilityData>
	{
		val out = FriendlyAttackAbility(data)
		return out
	}
}

class FriendlyBlockAbilityData : FriendlyPopTileAbilityData()
{
	override val classID: String = "Block"

	override fun load(xmlData: XmlData)
	{
	/* Autogenerated method contents. Do not modify. */
		super.load(xmlData)
	}
}

class FriendlyBlockAbility(data: FriendlyBlockAbilityData) : FriendlyPopTileAbility<FriendlyBlockAbilityData>(data)
{
	override fun getTargets(entity: Entity, grid: Grid): Array<Tile>
	{
		return grid.attackTiles
	}

	override fun copy(grid: Grid): FriendlyAbility<FriendlyBlockAbilityData>
	{
		val out = FriendlyBlockAbility(data)
		return out
	}
}

class FriendlyPopAbilityData : FriendlyPopTileAbilityData()
{
	override val classID: String = "Pop"

	override fun load(xmlData: XmlData)
	{
	/* Autogenerated method contents. Do not modify. */
		super.load(xmlData)
	}
}

class FriendlyPopAbility(data: FriendlyPopAbilityData) : FriendlyPopTileAbility<FriendlyPopAbilityData>(data)
{
	val tmpArray = Array<Tile>()

	override fun getTargets(entity: Entity, grid: Grid): Array<Tile>
	{
		tmpArray.clear()

		tmpArray.addAll(grid.sinkPathTiles)
		tmpArray.addAll(grid.breakableTiles)
		tmpArray.addAll(grid.attackTiles)
		tmpArray.addAll(grid.namedOrbTiles)

		return tmpArray
	}

	override fun copy(grid: Grid): FriendlyAbility<FriendlyPopAbilityData>
	{
		val out = FriendlyPopAbility(data)
		return out
	}
}

class FriendlyHealAbilityData : AbstractFriendlyAbilityData()
{
	override val classID: String = "Heal"

	val heartSprite: Sprite = AssetManager.loadSprite("Oryx/Custom/items/heart")
	var amount: Int = 1

	override fun load(xmlData: XmlData)
	{
	/* Autogenerated method contents. Do not modify. */
		super.load(xmlData)
		amount = xmlData.getInt("Amount", 1)
	}
}

class FriendlyHealAbility(data: FriendlyHealAbilityData) : FriendlyAbility<FriendlyHealAbilityData>(data)
{
	override fun activate(entity: Entity, grid: Grid)
	{
		val srcPos = entity.pos()?.tile ?: return

		for (tile in grid.friendlyTiles)
		{
			val friendly = tile.contents
			val healable = friendly?.healable() ?: continue

			val diff = tile.getPosDiff(srcPos)
			diff[0].y *= -1
			entity.renderable()?.renderable?.animation = BumpAnimation.obtain().set(0.2f, diff)

			val dst = tile.euclideanDist(srcPos)
			var animDuration = dst * 0.025f

			animDuration += 0.4f
			val heartSprite = data.heartSprite.copy()
			heartSprite.colour = Colour.GREEN
			heartSprite.animation = LeapAnimation.obtain().set(animDuration, diff, 1f + dst * 0.25f)
			heartSprite.animation = ExpandAnimation.obtain().set(animDuration, 0.5f, 1.5f, false)
			tile.effects.add(heartSprite)

			val healEffect = AssetManager.loadParticleEffect("Heal").getParticleEffect()
			healEffect.colour = Colour.GREEN
			healEffect.renderDelay = animDuration
			tile.effects.add(healEffect)

			tile.addDelayedAction(
				{
					healable.hp++
				}, animDuration )
		}

		for (condition in grid.level.defeatConditions)
		{
			if (condition is CompletionConditionDie)
			{
				val sprite = data.heartSprite.copy()
				val dst = condition.table.localToStageCoordinates(Vector2(Random.random() * condition.table.width, Random.random() * condition.table.height))
				val moteDst = dst.cpy() - Vector2(GridWidget.instance.tileSize / 2f, GridWidget.instance.tileSize / 2f)
				val src = GridWidget.instance.pointToScreenspace(srcPos)

				spawnMote(src, moteDst, sprite, GridWidget.instance.tileSize, {}, animSpeed = 0.35f, leap = true)
				srcPos.addDelayedAction(
					{
						condition.fractionalHp += 1f
						condition.updateFractionalHp()
					}, 0.35f)
			}
		}
	}

	override fun copy(grid: Grid): FriendlyAbility<FriendlyHealAbilityData>
	{
		val out = FriendlyHealAbility(data)
		return out
	}
}

class FriendlyMoveAbilityData : AbstractFriendlyAbilityData()
{
	override val classID: String = "Move"

	override fun load(xmlData: XmlData)
	{
	/* Autogenerated method contents. Do not modify. */
		super.load(xmlData)
	}
}

class FriendlyMoveAbility(data: FriendlyMoveAbilityData) : FriendlyAbility<FriendlyMoveAbilityData>(data)
{
	val tmpArray = Array<Tile>()

	override fun activate(entity: Entity, grid: Grid)
	{
		val pos = entity.pos() ?: return
		val srcPos = pos.tile ?: return
		var targetTile: Tile? = null

		// move out of sinkable way
		if (grid.sinkPathTiles.contains(srcPos) && grid.notSinkPathTiles.size > 0)
		{
			targetTile = grid.notSinkPathTiles.minBy { it.taxiDist(srcPos) }
		}

		// else move to closest target
		if (targetTile == null)
		{
			tmpArray.clear()

			val parentAI = entity.ai()?.ai as FriendlyAI
			for (ability in parentAI.abilities)
			{
				if (ability is FriendlyPopTileAbility)
				{
					val targets = ability.getTargets(entity, grid)

					if (targets.any { it.taxiDist(srcPos) <= ability.data.range })
					{
						// we are close enough, return
						return
					}

					tmpArray.addAll(targets)
				}
			}

			targetTile = tmpArray.minBy { it.taxiDist(srcPos) }
		}

		if (targetTile == null)
		{
			return
		}

		val dir = Direction.getDirection(srcPos, targetTile)

		val nextTile = grid.getTile(srcPos, dir)

		if (nextTile != null && nextTile.canHaveOrb && nextTile.contents?.matchable() != null && nextTile.contents?.special() == null)
		{
			pos.removeFromTile(entity)
			pos.tile = nextTile
			pos.addToTile(entity)

			val diff = nextTile.getPosDiff(srcPos)
			diff[0].y *= -1

			entity.renderable()?.renderable?.animation = MoveAnimation.obtain().set(0.25f, UnsmoothedPath(diff), Interpolation.linear)
		}
	}

	override fun copy(grid: Grid): FriendlyAbility<FriendlyMoveAbilityData>
	{
		val out = FriendlyMoveAbility(data)
		return out
	}
}